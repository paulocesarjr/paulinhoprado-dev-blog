---
title: Descomplicando a Busca Bin√°ria
slug: descomplicando-a-busca-binaria
description: Neste artigo, busco explicar os conceitos b√°sicos de uma busca bin√°ria, suas aplica√ß√µes e, por fim, apresentar um modelo pr√°tico em JavaScript.
date: 2024-03-20
lastUpdated: 2024-03-20
image: /images/descomplicando-a-busca-binaria/grapes-fruits.gif
tags:
  - Algoritmos
---

import Formula from '../../../src/components/formula.astro'

Recentemente, tenho dedicado uma parte significativa dos meus estudos √† compreens√£o de estruturas de dados e algoritmos. Apesar de ter passado a maior parte da minha carreira como desenvolvedor front-end, focado principalmente em design e interface do usu√°rio, sempre nutri uma curiosidade intr√≠nseca pela manipula√ß√£o eficiente de dados.

Neste artigo, busco explicar os conceitos b√°sicos de uma busca bin√°ria, suas aplica√ß√µes e, por fim, apresentar um modelo pr√°tico em JavaScript.

## O custo de uma busca

Quando come√ßamos a lidar com conjuntos de dados em programa√ß√£o, especialmente atrav√©s de listas, √© comum n√£o nos preocuparmos muito com o desempenho. Afinal, os principais objetivos ao optarmos pelo uso de uma lista s√£o organiza√ß√£o, consulta e remo√ß√£o dos dados.

Tomemos como exemplo a lista abaixo, onde temos uma estrutura armazenando o nome de 5 frutas. Nesse contexto, √© relativamente simples aplicar um la√ßo de repeti√ß√£o para encontrar o √≠ndice de uma fruta pelo nome. Do ponto de vista computacional, o custo para encontrar qualquer fruta nessa lista seria m√≠nimo.

```javascript
const frutas = ['Uva', 'Abacaxi', 'Mel√£o', 'Morango', 'Laranja'];

function buscarIndiceDaFrutaPeloNome(frutas = [], nome) {
  for (let i = 0; i < frutas.length; i++) {
    console.log(`Opera√ß√£o: ${i + 1}`);

    if (nome === frutas[i]) {
      return i;
    }
  }
}

const indiceUva = buscarIndiceDaFrutaPeloNome(frutas, 'Uva');
```

Entretanto, √© importante questionar se o custo operacional para retornar o √≠ndice da fruta `Uva` √© o mesmo para `Laranja`. A resposta √© n√£o. Embora neste exemplo os √≠ndices sejam apresentados quase que instantaneamente para cada item da lista, o custo operacional tende a aumentar √† medida que o item desejado est√° mais pr√≥ximo do fim da lista. Portanto, encontrar o √≠ndice de `Laranja` √© mais demorado para o computador do que encontrar o √≠ndice de `Uva`.

<img 
  src="/images/descomplicando-a-busca-binaria/grapes-fruits.gif" 
  alt="Menino segurando uva" 
  style="max-width: 100%; display: block; margin: 2rem auto;" 
/>

Isso se torna evidente quando contamos as opera√ß√µes executadas pela fun√ß√£o `buscarIndiceDaFrutaPeloNome` na tentativa de encontrar o √≠ndice correspondente √† fruta desejada.

Encontrar o √≠ndice da `Uva`:

| Opera√ß√£o |               Execu√ß√£o               |
| -------- | :----------------------------------: |
| 1        | üëâ Verifica se `Uva` √© igual a `Uva` |

Encontrar o √≠ndice da `Laranja`:

| Opera√ß√£o |                   Execu√ß√£o                   |
| -------- | :------------------------------------------: |
| 1        |    Verifica se `Uva` √© igual a `Laranja`     |
| 2        |  Verifica se `Abacaxi` √© igual a `Laranja`   |
| 3        |   Verifica se `Mel√£o` √© igual a `Laranja`    |
| 4        |  Verifica se `Morango` √© igual a `Laranja`   |
| 5        | üëâ Verifica se `Laranja` √© igual a `Laranja` |

Podemos observar que encontrar o √≠ndice da `Uva` requer apenas uma opera√ß√£o, j√° que este √© o primeiro elemento da lista. Portanto, podemos dizer que o custo dessa opera√ß√£o √© $ O(1) $ na nota√ß√£o [Big O](https://pt.wikipedia.org/wiki/Grande-O).

Por outro lado, encontrar o √≠ndice da `Laranja` requer 5 opera√ß√µes, j√° que este √© o √∫ltimo elemento da lista. Assim, podemos representar o custo dessa opera√ß√£o como $ O(n) $, onde $ n $ √© o n√∫mero de elementos na lista.

<img 
  src="/images/descomplicando-a-busca-binaria/frutas_binarias.png" 
  alt="Custo computacional" 
  style="max-width: 100%; display: block; margin: 2rem auto;" 
/>
<p style="text-align: center; font-size: 0.9rem; color: #555;">
  üí° Em buscas lineares, quanto mais distante o elemento procurado maior o custo computacional.
</p>

Claro, em um contexto com apenas algumas opera√ß√µes, como o exemplo das frutas, o custo computacional de cinco opera√ß√µes √© praticamente negligenci√°vel para um computador. No entanto, ao considerarmos um sistema com uma lista significativamente maior, como, por exemplo, 1.500 frutas, a hist√≥ria muda.

Se imaginarmos que cada opera√ß√£o leva 0.5 segundos para ser conclu√≠da, encontrar o √≠ndice da √∫ltima fruta na lista levaria aproximadamente 750 segundos. Isso se traduz em cerca de 12 minutos e meio de tempo de resposta do sistema. Portanto, embora o custo de cada opera√ß√£o seja pequeno, quando multiplicado pelo n√∫mero total de opera√ß√µes necess√°rias, o tempo total de processamento pode se tornar substancial.

Diante desse cen√°rio, surge a pergunta crucial: como podemos otimizar essa busca?

## Ordena√ß√£o √© o segredo

Geralmente, ao procurarmos um documento em uma pasta ou um contato em uma agenda, observamos que esses itens est√£o ordenados para facilitar sua localiza√ß√£o. Na programa√ß√£o, n√£o √© diferente.

Imagine uma lista com 7 n√∫meros:

```javascript
const numeros = [10, 23, 53, 87, 24, 2, 61]
```

Baseando-nos no exemplo anterior das frutas, uma busca linear (verificando item a item) para encontrar o √≠ndice do n√∫mero 2 custaria um total de 6 opera√ß√µes computacionais. E se ordenarmos essa lista?

```javascript
const numeros = [2, 10, 23, 24, 53, 61, 87]
```

Ap√≥s a ordena√ß√£o, precisar√≠amos de apenas 1 opera√ß√£o para o sistema encontrar o √≠ndice do n√∫mero 2. Mas ser√° que essa redu√ß√£o no custo operacional se aplica a todos os itens?

Vamos analisar o cen√°rio do n√∫mero 61. Na busca linear, precisar√≠amos de 6 opera√ß√µes para encontrar seu √≠ndice, mesmo com a lista ordenada. No entanto, ao inv√©s de come√ßarmos a busca pelo come√ßo, por que n√£o come√ßar pelo meio?

Para determinar o meio da lista, devemos considerar onde ela come√ßa e onde termina. Com essas informa√ß√µes, podemos fazer um simples c√°lculo somando o in√≠cio e o fim e dividindo por 2 para encontrar a metade exata. Assim, temos:

```javascript
const baixo = 0
const alto = numeros.length - 1
const meio = Math.floor((baixo + alto) / 2)
```

Onde na lista de n√∫meros o meio ser√° o √≠ndice 3, correspondente ao valor 24.

Dessa maneira, se considerarmos o √≠ndice 3 como ponto de partida para a lista, podemos iniciar nossa busca a partir desse elemento, uma vez que os valores est√£o ordenados:

| Opera√ß√£o |                   Execu√ß√£o                   |
| -------- | :------------------------------------------: |
| 1        |         Verifica se 24 √© igual a 61          |
| 2        | Reduz a lista pela metade, agora o meio √© 61 |
| 3        |         Verifica se 61 √© igual a 61          |

Come√ßando a busca pelo meio da lista, reduzimos o n√∫mero de opera√ß√µes de 6 para 3 at√© encontrarmos o n√∫mero 61. Esse √© o primeiro exemplo pr√°tico de como uma busca bin√°ria funciona.

> Com a pesquisa bin√°ria, voc√™ seleciona o n√∫mero intermedi√°rio de uma lista e elimina a metade dos n√∫meros restantes a cada opera√ß√£o.

<img 
  src="/images/descomplicando-a-busca-binaria/jim-carrey.gif" 
  alt="Todo poderoso separando sopa de tomate" 
  style="max-width: 100%; display: block; margin: 2rem auto;" 
/>
<p style="text-align: center; font-size: 0.9rem; color: #555;">
  üí° A metade dos elementos tamb√©m significa metade das opera√ß√µes.
</p>

Isso faz com que voc√™ n√£o precise ler todos os elementos da lista para encontrar o elemento desejado, uma vez que, a cada opera√ß√£o, a lista √© reduzida pela metade. Analisando os valores lidos da lista a cada opera√ß√£o bin√°ria, temos o seguinte comportamento:

| Opera√ß√£o |                      Execu√ß√£o                      |
| -------- | :------------------------------------------------: |
| 1        | `[2, 10, 23, 24, 53, 61, 87]` (verifica o meio 24) |
| 2        |          `[53, 61, 87]` (divide a lista)           |
| 3        |       üëâ `[53, 61, 87]` (verifica o meio 61)       |

Novamente, se considerarmos apenas uma lista com 7 elementos, talvez a diferen√ßa entre realizar 6 ou 3 opera√ß√µes em uma busca n√£o pare√ßa t√£o significativa para o sistema. No entanto, se ampliarmos o escopo para uma lista ordenada com 100 n√∫meros, a busca linear exigiria 100 opera√ß√µes para encontrar o √∫ltimo elemento. Por outro lado, a busca bin√°ria levaria **apenas 7 opera√ß√µes!**

Enquanto a busca linear opera na nota√ß√£o  <Formula formula="O(n)" />, a busca bin√°ria demonstra alto desempenho, reduzindo pela metade o n√∫mero de leituras a cada opera√ß√£o. Isso se traduz em:

<Formula formula="O(\log n)" display />

## Um belo algoritmo para buscar

Dado que em cada opera√ß√£o dividimos a lista e verificamos se o elemento no meio √© o valor desejado, podemos simplesmente aplicar essa l√≥gica em um loop de repeti√ß√£o para obter nosso algoritmo:

```javascript
function pesquisaBinaria(lista, item) {
  let baixo = 0;
  let alto = lista.length - 1;
  let meio, chute;

  while (baixo <= alto) {
    meio = Math.floor((baixo + alto) / 2);
    chute = lista[meio];

    if (chute === item) {
      return meio; // Retorna o √≠ndice se o item for encontrado
    }

    if (chute > item) {
      alto = meio - 1; // Descarta a metade superior da lista
    } else {
      baixo = meio + 1; // Descarta a metade inferior da lista
    }
  }

  return -1; // Retorna -1 se o item n√£o for encontrado na lista
}
```

Dessa forma, ao fornecermos uma lista ordenada para a fun√ß√£o `pesquisaBinaria` e especificarmos o valor desejado, receberemos o √≠ndice correspondente como retorno:

```javascript
const indice = pesquisaBinaria([1,3,5,7,9], 5)
console.log(indice) // 2
```

Por fim, vale ressaltar alguns pontos importantes sobre a implementa√ß√£o da busca bin√°ria:

- A busca bin√°ria requer que a lista esteja previamente ordenada.
- Em cada opera√ß√£o, a busca bin√°ria encontra a metade da lista e verifica se este √© o elemento desejado.
- Ao contr√°rio da busca linear, a busca bin√°ria opera em tempo logar√≠tmico.
- Quanto mais longa a lista, mais evidente se torna a vantagem da busca bin√°ria em rela√ß√£o √† busca linear.
