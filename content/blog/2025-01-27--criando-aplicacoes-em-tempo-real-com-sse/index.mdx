---
title: Criando aplica√ß√µes em tempo real com SSE (Server-Sent Events)
slug: criando-aplicacoes-em-tempo-real-com-sse
description: H√° cerca de uma d√©cada, se precis√°ssemos desenvolver uma aplica√ß√£o em tempo real, como um chat ou um feed de atualiza√ß√µes, a primeira solu√ß√£o que viria √† mente seria o uso de polling. Essa t√©cnica consiste em enviar requisi√ß√µes HTTP de forma temporizada e recorrente ao servidor, buscando dados atualizados.
date: 2025-01-27
lastUpdated: 2025-01-27
image: /images/criando-aplicacoes-em-tempo-real-com-sse/chat.gif
tags:
  - Front-end
---

H√° cerca de uma d√©cada, se precis√°ssemos desenvolver uma aplica√ß√£o em tempo real, como um chat ou um feed de atualiza√ß√µes, a primeira solu√ß√£o que viria √† mente seria o uso de polling. Essa t√©cnica consiste em enviar requisi√ß√µes HTTP de forma temporizada e recorrente ao servidor, buscando dados atualizados. No entanto, mesmo quando n√£o h√° novas informa√ß√µes dispon√≠veis, essas requisi√ß√µes continuam sendo disparadas, resultando em desperd√≠cio de recursos, como largura de banda e processamento do servidor.

<img
  src="/images/criando-aplicacoes-em-tempo-real-com-sse/chat.gif"
  alt="Mensagens"
  style={{ margin: "0 auto" }}
/>

Felizmente, os tempos mudaram. Hoje, ao trabalharmos com JavaScript, contamos com a biblioteca [EventSource](https://developer.mozilla.org/en-US/docs/Web/API/EventSource), que permite estabelecer uma conex√£o SSE (_Server-Sent Events_). Neste artigo, explorarei os conceitos por tr√°s desse recurso e apresentarei um breve tutorial para aplicar esses conceitos na pr√°tica.

## Uma conex√£o sempre aberta

Diferentemente das requisi√ß√µes HTTP convencionais, onde o cliente dispara uma requisi√ß√£o e o servidor devolve uma resposta, as conex√µes SSE permanecem sempre abertas. Isso possibilita uma comunica√ß√£o unidirecional entre servidor e cliente. Ao contr√°rio dos WebSockets, que permitem comunica√ß√£o bidirecional, no SSE apenas o servidor envia dados ao cliente, que os recebe de forma instant√¢nea enquanto est√° conectado.

<img
  src="/images/criando-aplicacoes-em-tempo-real-com-sse/http.png"
  alt="Diagrama de uma arquitetura HTTP cliente servidor"
  style={{ margin: "0 auto" }}
/>

Uma vez estabelecida a conex√£o, os dados chegam ao cliente JavaScript na forma de eventos, eliminando a necessidade de disparar novas requisi√ß√µes ao servidor para buscar atualiza√ß√µes, como acontece no polling. Cabe ao servidor a responsabilidade de enviar eventos com os dados atualizados sempre que necess√°rio.

<img
  src="/images/criando-aplicacoes-em-tempo-real-com-sse/sse.png"
  alt="Diagrama de uma arquitetura de uma conex√£o SSE"
  style={{ margin: "0 auto" }}
/>

A menos que a conex√£o seja encerrada, o cliente fica constantemente aguardando novos eventos de dados do servidor, tornando essa t√©cnica ideal para a constru√ß√£o de notifica√ß√µes, dashboards ou chats que necessitam de atualiza√ß√µes constantes.

## Sistema de controle de conex√µes

Para demonstrar na pr√°tica os conceitos abordados, vamos criar uma aplica√ß√£o em Node.js (back-end) respons√°vel por disponibilizar um endpoint de conex√£o SSE, que ser√° utilizado por um cliente JavaScript (front-end).

> Nossa aplica√ß√£o consiste em um sistema onde o usu√°rio deve informar um UserID e estabelecer uma conex√£o SSE. A partir disso, o servidor come√ßa a disparar, a cada 5 segundos, um evento que retorna a lista de usu√°rios conectados. Caso o usu√°rio encerre sua conex√£o, ele √© removido automaticamente da lista de usu√°rios conectados.

Vamos come√ßar!

```
npm init -y

npm i express
```

Ao criar o arquivo `index.js`, vamos centralizar a l√≥gica do nosso back-end. Al√©m disso vamos criar um pasta `/public` onde ficar√£o o `index.html` e arquivo `script.js` para gerenciar nossa p√°gina. A estrutura deve ficar assim:

```
/public
  index.html
  script.js
index.js
package.json
```

Em `index.js`, vamos importar a biblioteca `express`, que √© respons√°vel por permitir a cria√ß√£o de endpoints HTTP:

```javascript
import express from "express";

const app = express();
app.use(express.json());

const PORT = 3000;
app.listen(PORT, () => console.log(`Server is running on ${PORT} port`));
```

Al√©m disso, √© necess√°rio configurar para que o conte√∫do da pasta `/public` seja retornado quando o usu√°rio acessar `http://localhost:3000/`:

```javascript
import express from "express";
import fs from "fs";
import path from "path";

const app = express();
app.use(express.json());
app.use(express.static(path.join(path.resolve(path.dirname("")), "public")));

app.get("/", (_, res) => {
  res.writeHead(200, { "content-language": "text/html" });
  const streamIndexHtml = fs.createReadStream("index.html");
  streamIndexHtml.pipe(res);
});

const PORT = 3000;
app.listen(PORT, () => console.log(`Server is running on ${PORT} port`));
```

Dentro de `/public` em `index.html` vamos montar um HTML b√°sico para retornar um t√≠tulo e testar o funcionando do servidor:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Server Sent Events Demo</title>
  </head>
  <body>
    <h1>Server Sent Events Demo (SSE)</h1>
  </body>
</html>
```

Agora, ao rodar o comando `npm start` no terminal, a p√°gina j√° deve ser exibida no navegador:

<img
  src="/images/criando-aplicacoes-em-tempo-real-com-sse/tutorial-01.png"
  alt="Tutorial 01"
  style={{ margin: "0 auto" }}
/>

Voltando as aten√ß√µes para o back-end, podemos criar arquivo `connection.js`, respons√°vel por gerenciar as conex√µes do usu√°rios ao servidor:

```
/public
  index.html
  script.js
index.js
connection.js
package.json
```

Dentro dele, vamos exportar uma classe `Connection`, onde ser√° armazenado um mapa de usu√°rios conectados, al√©m dos m√©todos `registerUser`, para registrar novos usu√°rios, e `removeUser`, para remov√™-los do mapa:

```javascript
export default class Connection {
  _users = new Map();

  registerUser() {}

  removeUser() {}
}
```

Tamb√©m podemos criar um getter `connectedUsers` para facilitar o acesso aos usu√°rios conectados fora da classe:

```javascript
export default class Connection {
  _users = new Map();

  get connectedUsers() {
    return [...this._users.keys()];
  }

  registerUser() {}

  removeUser() {}
}
```

No m√©todo registerUser, vamos receber o `userId` do usu√°rio conectado e gerar um `connectionId`, que servir√° como identificador √∫nico para essa conex√£o estabelecida:

```javascript
registerUser(userId, response) {
  if (!this._users.has(userId)) {
    this._users.set(userId, [])
  }

  const connectionId = this.generateConnectionId()
  this._users.get(userId).push({ connectionId, response })
  return connectionId
}
```

No m√©todo `generateConnectionId`, podemos utilizar a biblioteca `crypto` para gerar e retornar um token aleat√≥rio:

```javascript
generateConnectionId() {
  return crypto.randomBytes(20).toString("hex")
}
```

J√° o m√©todo `removeUser` receber√° o `userId` e o `connectionId` do usu√°rio que fechou a conex√£o, e, com isso, remover√° o usu√°rio do mapa:

```javascript
removeUser(userId, connectionId) {
  if (!this._users.has(userId)) {
    return
  }

  const connections = this._users
    .get(userId)
    .filter((connection) => connection.connectionId !== connectionId)

  if (connections.length) {
    this._users.set(userId, connections)
  } else {
    this._users.delete(userId)
  }
}
```

Como a classe `Connection` isola a l√≥gica de gerenciamento das conex√µes, precisamos configurar um endpoint em nosso servidor (`index.js`) para que os clientes possam iniciar uma comunica√ß√£o SSE. Essas conex√µes, por sua vez, ser√£o gerenciadas pela classe `Connection`:

```javascript
const connection = new Connection();

app.get("/events", (req, res) => {
  res
    .writeHead(200, {
      "Cache-Control": "no-cache",
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
    })
    .write("\n");

  const EVENTS_INTERVAL = 5000;
  const userId = req.query.user;
  const connectionId = connection.registerUser(userId, res);

  setInterval(() => {
    res.write(`data: ${JSON.stringify(connection.connectedUsers)}\n\n`);
  }, EVENTS_INTERVAL);

  req.on("close", () => connection.removeUser(userId, connectionId));
});
```

Aqui podemos destacar tr√™s pontos importantes:

1. O endpoint `/events` deve responder ao cliente com o cabe√ßalho `Content-Type: text/event-stream`. Isso permite que os clientes reconhe√ßam a comunica√ß√£o SSE e criem um objeto `EventSource` para estabelecer a conex√£o.

2. A cada cinco segundos, o servidor enviar√° uma resposta em forma de evento para os clientes conectados, informando quais usu√°rios estabeleceram conex√£o.

3. Conex√µes encerradas podem ser monitoradas utilizando o evento `req.on("close", () => {})`, permitindo que usu√°rios desconectados sejam removidos do mapa de conex√µes.

Nosso back-end est√° pronto! Agora podemos voltar nossa aten√ß√£o para o front-end.

Como o servidor j√° disponibiliza um endpoint para conex√µes SSE, cabe ao cliente requisitar esse endere√ßo e aguardar o recebimento dos eventos enviados.

No arquivo `index.html`, vamos criar:

- Um campo de texto para o usu√°rio informar seu UserID;
- Dois bot√µes: um para iniciar e outro para encerrar a conex√£o SSE;
- Uma tag `<ul>` para exibir a lista de usu√°rios conectados, que ser√° atualizada com os eventos enviados pelo servidor.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Server Sent Events Demo</title>
  </head>
  <body>
    <h1>Server Sent Events Demo (SSE)</h1>

    <input type="text" id="userIdTxt" placeholder="User ID" />
    <input type="button" id="connectBtn" value="Connect" />
    <input type="button" id="closeBtn" value="Close" disabled />
    <ul id="users"></ul>
    <script type="text/javascript" src="script.js"></script>
  </body>
</html>
```

Por fim, no arquivo `script.js` para isolar a l√≥gica de manipula√ß√£o dos componentes e a cria√ß√£o do objeto `EventSource`.

```javascript
let eventSource = null;
const userIdInput = document.querySelector("#userIdTxt");
const connectButton = document.querySelector("#connectBtn");
const closeButton = document.querySelector("#closeBtn");
const ulUsers = document.querySelector("#users");

connectButton.addEventListener("click", startConnection);
closeButton.addEventListener("click", closeConnection);

function startConnection() {
  const userId = userIdInput.value.trim();
  if (!userId) {
    alert("Please enter a User ID");
    return;
  }

  eventSource = new EventSource(`/events?user=${userId}`);
  connectButton.setAttribute("disabled", "");
  closeButton.removeAttribute("disabled");
  userIdInput.setAttribute("disabled", "");

  eventSource.onmessage = (event) => {
    const connectedUsers = JSON.parse(event.data);
    updateUsersList(connectedUsers);
  };
}

function updateUsersList(users) {
  ulUsers.innerHTML = "";

  users.forEach((user) => {
    const liUser = document.createElement("li");
    liUser.textContent = user;
    ulUsers.appendChild(liUser);
  });
}

function closeConnection() {
  eventSource.close();

  ulUsers.innerHTML = "";
  connectButton.removeAttribute("disabled");
  userIdInput.removeAttribute("disabled");
  closeButton.setAttribute("disabled", "");
}
```

Aqui, destacamos a cria√ß√£o do objeto `eventSource`:
`` eventSource = new EventSource(`/events?user=${userId}`) ``.

No construtor, ele espera como argumento um servidor que responda com o conte√∫do `text/event-stream`. Por sorte, j√° configuramos exatamente isso! üòú

A fun√ß√£o `eventSource.onmessage(event => {})` permite receber em tempo real todos os eventos enviados pelo servidor de forma unidirecional.

Para evitar que a conex√£o permane√ßa aberta indefinidamente, podemos utilizar `eventSource.close()`, que fecha o canal de comunica√ß√£o com o servidor. Alternativamente, a conex√£o tamb√©m ser√° encerrada ao fechar o navegador.

## A magia do tempo real

Ao abrir duas abas da nossa aplica√ß√£o no navegador, podemos validar o funcionamento da conex√£o em tempo real, observando as atualiza√ß√µes de usu√°rios conectados em a√ß√£o.

<img
  src="/images/criando-aplicacoes-em-tempo-real-com-sse/sse-application.gif"
  alt="SSE Application"
  style={{ margin: "0 auto" }}
/>

Note que, enquanto a conex√£o SSE permanecer aberta, os eventos continuar√£o sendo recebidos a cada 5 segundos, atualizando automaticamente a lista de usu√°rios conectados ao servidor.

<img
  src="/images/criando-aplicacoes-em-tempo-real-com-sse/network.png"
  alt="Aba Network do Browser"
  style={{ margin: "0 auto" }}
/>

Com isso, conclu√≠mos a implementa√ß√£o de um sistema simples utilizando SSE para conex√µes em tempo real. Essa t√©cnica √© ideal para casos em que o servidor precisa enviar dados cont√≠nuos e unidirecionais para o cliente, como feeds, chats ou dashboards. Se voc√™ quiser conferir o c√≥digo completo deste projeto, acesse meu reposit√≥rio no GitHub: [Server Sent Events](https://github.com/paulocesarjr/server-sent-events).
