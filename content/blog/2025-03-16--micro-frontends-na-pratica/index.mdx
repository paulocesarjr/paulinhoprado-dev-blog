---

title: Micro-frontends na pr√°tica
slug: micro-frontends-na-pratica
description: H√° alguns anos, trabalhei em uma empresa onde tentamos dividir uma √∫nica aplica√ß√£o front-end em partes menores, independentes e isoladas. Bom... n√£o deu muito certo. Talvez por falta de conhecimento ou pelas limita√ß√µes tecnol√≥gicas da √©poca.
date: 2025-03-16
lastUpdated: 2025-03-16
image: /images/micro-frontends-na-pratica/simpsons-homer.gif
tags:
- Front-end

---

H√° alguns anos, trabalhei em uma empresa onde tentamos dividir uma √∫nica aplica√ß√£o front-end em partes menores, independentes e isoladas. Bom... n√£o deu muito certo. Talvez por falta de conhecimento ou pelas limita√ß√µes tecnol√≥gicas da √©poca. O resultado foi uma SPA (_Single Page Application_) em Angular que carregava diversos _iframes_, cada um executando outra SPA em Angular. De fato, conseguimos um certo "desacoplamento", mas, em contrapartida, a performance da aplica√ß√£o principal despencou. O alto consumo de mem√≥ria e a demora para carregar os _iframes_ tornaram claro que teria sido melhor manter tudo em uma √∫nica aplica√ß√£o.

<img
  src="/images/micro-frontends-na-pratica/simpsons-homer.gif"
  alt="Homer Simpson"
  style={{ margin: "0 auto" }}
/>

Mesmo ap√≥s esse desafio, a experi√™ncia n√£o me desanimou. A ideia por tr√°s dos Micro-frontends continuava me fascinando, e eu n√£o conseguia aceitar completamente que a tentativa havia dado errado. Por isso, segui estudando o conceito e buscando maneiras mais eficientes de implement√°-lo. Neste artigo, quero apresentar uma abordagem que teria sido muito √∫til naquela √©poca ‚Äî e que pode ajudar quem enfrenta desafios semelhantes.

## Dividir para conquistar

O conceito de Micro-frontends √© simples de entender. Diferente das aplica√ß√µes monol√≠ticas, onde todo o front-end √© carregado e servido por uma √∫nica estrutura, os Micro-frontends permitem que pequenos componentes sejam isolados e carregados independentemente por uma ou mais aplica√ß√µes.

<img
  src="/images/micro-frontends-na-pratica/micro-frontends.png"
  alt="Arquitetura de micro-frontend"
  style={{ margin: "0 auto" }}
/>

Imagine uma loja virtual com v√°rios elementos na tela, cada um com uma fun√ß√£o espec√≠fica. Se toda a interface for disponibilizada por um √∫nico servidor, temos um front-end monol√≠tico. Mas se, por exemplo, o carrinho de compras for muito complexo e exigir regras de neg√≥cio espec√≠ficas, ele pode ser desacoplado e hospedado separadamente, at√© mesmo em um reposit√≥rio diferente. Dessa forma, outras lojas virtuais podem reutiliz√°-lo facilmente, garantindo maior flexibilidade e escalabilidade.

Um dos grandes diferenciais dos Micro-frontends √© a flexibilidade tecnol√≥gica. N√£o √© necess√°rio restringir-se a um √∫nico _framework_ para desenvolver toda a aplica√ß√£o. √â poss√≠vel criar componentes em diferentes tecnologias e integr√°-los a uma aplica√ß√£o central.

Por exemplo, imagine um sistema de aluguel de im√≥veis onde o front-end principal √© feito em React, mas os componentes respons√°veis por exibir as informa√ß√µes dos im√≥veis s√£o Micro-frontends desenvolvidos em Angular.

<img
  src="/images/micro-frontends-na-pratica/micro-frontend-imoveis.png"
  alt="Aplica√ß√£o de aluguel de im√≥veis com Micro-frontends"
  style={{ margin: "0 auto" }}
/>

Essa interoperabilidade √© uma das grandes vantagens do desacoplamento. No fim das contas, tudo √© JavaScript!

## Federation

Em um belo dia, o Webpack introduziu o [Module Federation](https://webpack.js.org/concepts/module-federation/) na vers√£o 5, revolucionando a forma como aplica√ß√µes compartilham depend√™ncias. Esse recurso permite definir m√≥dulos que podem ser carregados dinamicamente, mesmo estando em projetos diferentes.

Na pr√°tica, ele define uma aplica√ß√£o container (_host_), respons√°vel por carregar m√≥dulos independentes expostos (_remotes_) por outras aplica√ß√µes. Essa abordagem torna os Micro-frontends ainda mais eficientes, aplicando [_Code Splitting_](https://webpack.js.org/guides/code-splitting/) para carregar componentes sob demanda, evitando que fa√ßam parte do bundle final desnecessariamente.

Para demonstrar essa m√°gica na pr√°tica, vamos criar duas aplica√ß√µes React simples que, juntas, formar√£o uma dashboard de jogadores de um time de futebol. A ideia √© que a lista de jogadores seja uma aplica√ß√£o independente, desenvolvida em React, e que ser√° carregada como um Micro-frontend dentro da aplica√ß√£o principal, que ser√° respons√°vel por exibi-la.

Vamos utilizar o [Vite](https://vite.dev/) para criar duas aplica√ß√µes React:

- **container**: a aplica√ß√£o principal, que servir√° como host do Micro-frontend.
- **players** : a aplica√ß√£o independente que exibir√° a lista de jogadores.

No **container**, o componente `App.jsx` ter√° um HTML b√°sico com um t√≠tulo para a aplica√ß√£o:

```jsx
// üìÇ container/src/App.jsx

import "./App.css";

function App() {
  return (
    <>
      <h1>‚öΩ Soccer Dashboard Micro-frontend</h1>
    </>
  );
}

export default App;
```

No nosso projeto **players**, criaremos um componente `Players.jsx` que far√° uma listagem de jogadores de futebol. Ao clicar em um jogador, acionaremos uma fun√ß√£o de callback para enviar seus dados para uso externo:

```jsx
// üìÇ players/src/Players.jsx

import "./Player.css";

const team = [
  {
    name: "Martin Braithwaite",
    photo:
      "https://s3p.sofifa.net/5f55c5509a088da5658cfc69b31be62f7595778e.png",
    position: "ATA",
  },
  {
    name: "Franco Cristaldo",
    photo:
      "https://s3p.sofifa.net/8909750ea3bdec2d403fd56c3bfe5571e7880a52.png",
    position: "MEI",
  },
  {
    name: "Gustavo Cuellar",
    photo:
      "https://s3p.sofifa.net/14b4aaa618de1a853f4298694e7751ec30a43f7b.png",
    position: "VOL",
  },
  {
    name: "Jamerson",
    photo:
      "https://s3p.sofifa.net/f12d7b370613b35527a35a328716313dfbdbde94.png",
    position: "ZAG",
  },
  {
    name: "Tiago Volpi",
    photo:
      "https://s3p.sofifa.net/04736af5928a0443fa2ec4bf8d84e1524cfde82d.png",
    position: "GOL",
  },
];

function Players({ onPlayerSelected }) {
  return (
    <ul className="team">
      {team.map((player, index) => (
        <a
          key={index}
          className="team__player"
          onClick={() => onPlayerSelected(player)}
        >
          <li>
            <div>
              <img
                src={player.photo}
                alt={player.name}
                className="team__player--photo"
              />
            </div>
            <div className="team__player--info">
              <p>
                <strong>Nome:</strong> {player.name}
              </p>
              <p>
                <strong>Posi√ß√£o:</strong> {player.position}
              </p>
            </div>
          </li>
        </a>
      ))}
    </ul>
  );
}

export default Players;
```

Uma vez que nossos componentes foram criados, chegou a hora de carregar o componente `Players.jsx` como um Micro-frontend dentro do `App.jsx` do projeto **container**. Para isso, vamos instalar uma abstra√ß√£o do Module Federation feita especificamente para o Vite: [`vite-plugin-federation`](https://github.com/originjs/vite-plugin-federation).

Em ambos os projetos, **container** e **players**, vamos rodar o seguinte comando:

```
yarn add @originjs/vite-plugin-federation --dev
```

No projeto **players**, em `players/vite.config.js`, vamos importar a biblioteca federation e definir um nome para nosso Micro-frontend. Al√©m disso, especificaremos na propriedade `exposes` quais componentes React ser√£o disponibilizados para outras aplica√ß√µes.

A propriedade `filename` define um arquivo JavaScript que cont√©m o bundle desses componentes expostos.

```js
// üìÇ players/vite.config.js

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import federation from "@originjs/vite-plugin-federation";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    federation({
      name: "players",
      filename: "remoteEntry.js",
      exposes: {
        "./Players": "./src/Players",
      },
      shared: ["react", "react-dom"],
    }),
  ],
  build: {
    target: "esnext",
    minify: false,
    cssCodeSplit: false,
  },
  preview: {
    host: "localhost",
    port: 5002,
    strictPort: true,
    headers: {
      "Access-Control-Allow-Origin": "*",
    },
  },
});
```

Ao executar o comando `yarn vite preview`, podemos acessar esse arquivo no navegador atrav√©s de `http://localhost:5002/assets/remoteEntry.js`.

<img
  src="/images/micro-frontends-na-pratica/remoteEntry.png"
  alt="Arquivo remoteEntry.js"
  style={{ margin: "0 auto" }}
/>

J√° no projeto **container**, em `container/vite.config.js`, vamos importar a biblioteca `federation` e definir, na propriedade `remotes`, o endere√ßo do bundle do componente players. Com isso, ele passar√° a ser disponibilizado dentro do escopo desse projeto:

```js
// üìÇ container/vite.config.js

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import federation from "@originjs/vite-plugin-federation";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    federation({
      name: "container_app",
      remotes: {
        players: "http://localhost:5002/assets/remoteEntry.js",
      },
      shared: {
        react: {
          singleton: true,
          requiredVersion: "^18.0.0",
        },
        "react-dom": {
          singleton: true,
          requiredVersion: "^18.0.0",
        },
      },
    }),
  ],
  build: {
    modulePreload: false,
    target: "esnext",
    minify: false,
    cssCodeSplit: false,
  },
});
```

Ap√≥s configurar corretamente o Federation, podemos importar o componente `Players.jsx` dentro de `App.jsx`, como se ele fosse parte integrante do mesmo projeto. Esse processo torna o Micro-frontend funcional, permitindo que o componente seja carregado e utilizado na aplica√ß√£o principal sem complica√ß√µes, mantendo a estrutura modular e desacoplada:

```jsx
import "./App.css";
import Players from "players/Players";

function App() {
  return (
    <>
      <h1>‚öΩ Soccer Dashboard Micro-frontend</h1>
      <Players />
    </>
  );
}

export default App;
```

Podemos expandir ainda mais a funcionalidade ao acessar o callback `onPlayerSelected` no projeto **container**. Dessa forma, quando um jogador for selecionado na aplica√ß√£o de **players**, suas informa√ß√µes ser√£o passadas para o projeto **container**. No `App.jsx` do **container**, podemos capturar esses dados e exibi-los, proporcionando uma integra√ß√£o din√¢mica entre os Micro-frontends.

Isso mant√©m a modularidade e desacoplamento, enquanto ainda permite a comunica√ß√£o entre os componentes de diferentes projetos:

```jsx
import { useState } from "react";
import "./App.css";
import Players from "players/Players";

function App() {
  const [player, setPlayer] = useState(null);

  const selectPlayer = (player) => {
    setPlayer(player);
  };

  return (
    <>
      <h1>‚öΩ Soccer Dashboard Micro-frontend</h1>
      <div className="dashboard">
        <div className="dashboard__team">
          <Players onPlayerSelected={selectPlayer} />
        </div>
        <div className="dashboard__player">
          {player && (
            <>
              <h2>{player.name}</h2>
              <img
                className="dashboard__player--photo"
                src={player.photo}
                alt="Foto do Jogador"
              />
              <h3>{player.position}</h3>
            </>
          )}
          {!player && <h2>Selecione um dos jogadores a esquerda</h2>}
        </div>
      </div>
    </>
  );
}

export default App;
```

Ap√≥s rodar o comando `yarn build && yarn vite preview` no projeto **players**, ele estar√° pronto para expor o componente `Players.jsx`. J√° no projeto **container**, ao rodar `yarn run dev`, a aplica√ß√£o estar√° dispon√≠vel em `http://localhost:5173/`. L√°, voc√™ poder√° visualizar a aplica√ß√£o React completa, com o Micro-frontend do componente de jogadores integrado e interativo, exibindo as informa√ß√µes corretamente ao clicar em cada jogador.

<img
  src="/images/micro-frontends-na-pratica/aplicacao_final.png"
  alt="Aplica√ß√£o final com Micro-frontend"
  style={{ margin: "0 auto" }}
/>

Ao explorar a implementa√ß√£o de Micro-frontends, vimos que essa abordagem pode trazer grandes benef√≠cios, como maior modulariza√ß√£o, escalabilidade e flexibilidade no uso de diferentes tecnologias. Por√©m, tamb√©m existem desafios, como a complexidade adicional na comunica√ß√£o entre Micro-frontends e a poss√≠vel sobrecarga de performance. Esses aspectos devem ser considerados ao escolher adotar essa arquitetura. Para conferir o c√≥digo completo do projeto, acesse meu reposit√≥rio no GitHub: [Soccer Dashboard Micro-frontend](https://github.com/paulocesarjr/soccer-dashboard-microfrontend).
